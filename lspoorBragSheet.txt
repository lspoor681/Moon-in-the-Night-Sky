For this project I thought I would go for something that was more encompassing, so I chose to make sure that everything would work well in tandem, allowing for the scalability and reliability of every function to be used in every situation without failure because I purposely avoided hard coding actions into the program. I started doing this by basing everything off of the width and height of each individual window respectively, dividing their values to get the world coordinate equivalent. From here I would be able to place the buttons and text in the control panel without having to worry about the size of it changing and suddenly having to fix a out of sight piece of text. This brought me to the issue of making the buttons which ended up not being as difficult as I thought they would be. The radio button's signature is that they can only have one selected at a time, I thought that I would attack this issue by using a switch statement that would individual draw one of the buttons when given a value, this would ensure that only one is drawn, because if the value was ever changed, the screen would be redrawn and the old one would be cleaned from memory and the new would new drawn into place. A similarly simple solution was found for the check boxes, as they can be activated at anytime, in any order, independent of each other, I thought it would be best if I used an array, which would hold boolean values for each, true or false; and these values could be checked or changed at any time and not affect the others in the array. To draw the boxes I did a simple square that stemmed from one center point, and then for the X to check it I just switched the vertexes to make the lines cross each other. When adding the moon, I found the hardest part was to get the moon to cooperate with the rest of the environment, specifically regarding the clipping planes. However, after some finagling around with pushing and popping the matrix to get the transitions right I found that simplicity was best once again. I used a global variable to hold the angle of rotation, and would increment it by the buttons and a keyboard button 'm.' Finding the right way to coordinate the buttons with the independent rotating of the moon was difficult, as it required a separate function which would check the angle and then relay its position back the button function to keep up with it. Once the base of the moon function was set, adding scaling and transitions to it was not difficult, simply get a global scaling faction, and a x and y value to translate, we could just change the values based on input and it would respond in kind. From here we could match it up with the mouse movement function allowing us to set the position of the mouse cursor to the center of the moon when dragging allowing us to click, drag, and place the moon with our mouse. To do so was very similar to the action of clicking a button, just setting a bound based on the moon's whereabouts based on its center and radius. To add some flavor, I decided to add a background of stars, which could be turned off and on. To do so I just created two arrays and filled them with random numbers in the range of our window, and used a number from each as a x and y value. I could have used one, but this was simpler as I had already implemented it. I also allow the user to dictate how many stars are shown, but using a variable which will only draw a certain number of stars on the screen depending on a variable which can be increased or decreased with the use of the +/-. From here I saw a possibility of adding in even more so I went with something bold, a series of galaxies. To be honest I was completely unsure on how to go about this at first, I knew using a helix would be a good idea as it is already in the spiral shape necessary, however it is going in the wrong direction. After a lot of toying around with the coordinated and settings of the helix, I was able to change the nature of the helix to reduce its own radius instead of changing its height. From here it was only a question of making more of them in a way that looks like a galaxy with many arms. To do so I decided to have a function take an integer of the number of arms and evenly distribute that number around a circle and then draw a single spiral helix from each point making a perfectly even galaxy. This was good, but I could do more, so I stippled them to give them even more of a story look. The whole reason I wanted to get galaxies was to make them spin so I tried for a long time to get them to spin properly, but I was realizing that I was having the issue of not spinning them around their true center, so I had to back track to their creation and place the rotation in the create galaxy function which causes them all to spin at the same time, which I think is very cool. Use r to manually rotate them. However, I could do better, and I implemented the automation from rotatingHelixV4.cpp to cause both the moon and the galaxies to spin if you press G for the galaxies and M for the moon. It should be noted that the automation will continue to work with the correlation of the buttons on the control panel. Lastly I threw in some other objects just to brighten up the world a bit. I though the little and big dipper while, maybe boring seemed iconic enough to place in our world.


Last minute I added a second planet I didn't have enough time to flesh it out entirely, however, I make it have a ring which would rotate around the plant, as well as the planet being about to rotate itself around the moon, which I quickly was able to automate with the O key, and o key for manual. The t key allows the ring to rotate around the planet.